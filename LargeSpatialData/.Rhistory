set.seed(111)
y<- 2.0 +  .1*x  - .1*x^2 + 5*rnorm( 50)
plot( x,y)
x<- 1:50
set.seed(111)
y<- 2.0 -  .1*x  + .1*x^2 + 5*rnorm( 50)
plot( x,y)
x<- 1:50
set.seed(111)
y<- 2.0 -  .1*x  + .1*x^2/(1+x^2) + 5*rnorm( 50)
plot( x,y)
x<- 1:50
set.seed(111)
y<- 2.0 -  .1*x  + x^2/(1+x^2) + 5*rnorm( 50)
plot( x,y)
x<- 1:50
set.seed(111)
y<- 2.0 -  .1*x  + x^2/(1+x^2) + rnorm( 50)
plot( x,y)
x<- 1:50
set.seed(111)
y<- 2.0   .1*x  + 3*x^2/(1+x^2) + rnorm( 50)
x<- 1:50
set.seed(111)
y<- 2.0   +.1*x  + 3*x^2/(1+x^2) + rnorm( 50)
plot( x,y)
x<- seq( 0,2,length.out=50)
set.seed(111)
y<- 2.0   +.1*x  + 3*x^2/(1+x^2) + rnorm( 50)
plot( x,y)
x<- seq( 0,2,length.out=50)
set.seed(111)
y<- 2.0   +.1*x  + 3*x^2*(1-x)^3 + rnorm( 50)
plot( x,y)
x<- seq( 0,2,length.out=50)
set.seed(111)
y<- 10   +.1*x  + 3*x^2*(1-x)^3 + rnorm( 50)
plot( x,y)
x<- seq( 0,2,length.out=50)
set.seed(111)
y<- 10   +.1*x  + 3*x^2*(1-x)^3 + .5*rnorm( 50)
plot( x,y)
library( fields)
look<- sreg( x,y, lambda=.01)
lines( x, look$fitted.values, col="red")
library( fields)
look<- sreg( x,y, lambda=.001)
lines( x, look$fitted.values, col="red")
X<- cbind( 1, x)
Sigma<- Tps.cov(x,x)
plot( x,y)
look<- sreg( x,y, lambda=1e-3)
ghat2<- look$fitted.values
ghat3<- Tps( x,y, lambda=1e-3)
lines( x, gHat, col="red")
# generate data and make inot one column matrices.
x<- seq( 0,2,length.out=50)
x<- cbind( x)
set.seed(111)
y<- 10   +.1*x  + 3*x^2*(1-x)^3 + .5*rnorm( 50)
y <- cbind( y)
ghat2<- sreg( x,y, lambda=1e-3)$fitted.values
ghat3<- Tps( x,y, lambda=1e-3)$fitted.values
ghat2- ghat3
ghat2<- sreg( x,y, lambda=1e-3*n)$fitted.values
ghat3<- Tps( x,y, lambda=1e-3)$fitted.values
ghat2- ghat3
ghat2<- sreg( x,y, lambda=1e-3/n)$fitted.values
ghat3<- Tps( x,y, lambda=1e-3)$fitted.values
ghat2<- sreg( x,y, lambda=1e-3/n)$fitted.values
ghat3<- Tps( x,y, lambda=1e-3, scale="unscaled")$fitted.values
ghat2- ghat3
lambda<- 1e-3
n<- length( y)
M<-  solve( Sigma + lambda*diag(1,n))
cardinalX<- cbind(quantile( x, c(.25,75))
)
cardinalX<- cbind(quantile( x, probs=c(.25,.75))
)
cardinalX
Sigma<- Tps.cov(x,x, cardinalX = cardinalX)
lambda<- 1e-3
n<- length( y)
M<-  solve( Sigma + lambda*diag(1,n))
# GLS estimate of beta
betaHat<- solve( t(X)%*%M%*%X),  t(X)%*%M%*%y)
betaHat<- solve( t(X)%*%M%*%X,  t(X)%*%M%*%y )
# conditional expectation of g given data and using betaHat
# as an empirical Bayes plug in estimate.
gHat<- Sigma%*%M%*%( y - X%*%betaHat)
yHat<- X%*%betaHat + gHat
yHat
plot( x,y)
lines( x,yHat, col="red")
lines( x, yHat2, col="blue")
lines( x, yHat2, col="blue")
yHat2<- sreg( x,y, lambda=1e-3/n)$fitted.values
yHat3<- Tps( x,y, lambda=1e-3, scale="unscaled")$fitted.values
lines( x, yHat2, col="blue")
stats( cbind( yHat-yhat2, yHat2-yHat3))
yHat2<- sreg( x,y, lambda=1e-3/n)$fitted.values
yHat3<- Tps( x,y, lambda=1e-3, scale="unscaled")$fitted.values
lines( x, yHat2, col="blue")
stats( cbind( yHat-yHat2, yHat2-yHat3))
A<- diag( 1, 5)
A[ cbind(2:5,1:4)]<- -.2
A
A[ cbind(1:4,2:5)]<- -.2
A
chol(A)
L<-  diag( 4,5)
L[cbind(2:5, 1:4)]<- -1
L%*%t(L)
L<-  diag( 3,5)
L%*%t(L)
L[cbind(2:5, 1:4)]<- -1
L%*%t(L)
A<- diag( 9, 4)
A<- diag( 9, 5)
A[1,2:5]<-1
A[2:5,1]<-1
A
chol(A)
A1<- diag( 9, 5)
A1[1,2:5]<-1
A1[2:5,1]<-1
A2<- diag( 9, 5)
A2[5,2:5]<-1
A2[2:5,5]<-1
chol(A)
chol( A2)
A[c( 2:5,1), c( 2:5,1)]
A[c( 2:5,1), c( 2:5,1)]
A<- A[c( 2:5,1), c( 2:5,1)]
A
A<- A[c( 2:5,1), c( 2:5,1)]
A
A<- A[c( 2:5,1), c( 2:5,1)]
A
setwd("~/Dropbox/Data/LENSStatmos")
knitr::opts_chunk$set(echo = TRUE, fig.width=5, fig.height=5, fig.align = "center")
suppressMessages(library( LatticeKrig))
set.seed(222)
tabSP<- NULL
nObs<- c( 100,200,400,500,750,1000,1500)
for( n in nObs ){
x<- cbind( seq( 0,1,,n))
Sigma<- Matern( rdist(x,x)/.15, smoothness = 1.0)
U<- rnorm(n)
E<- rnorm(n)
# add in a linear part too to match fitting
y<-   (1 + x) + t(chol(Sigma))%*%U  + .05*E
# fix the range to compare with example later on
elapsedTime<- system.time(
out<- spatialProcess( x,y, aRange=.15 )
)
#print(c( n,elapsedTime[3]) )
tabSP<-  rbind( tabSP, c( n,elapsedTime[3]) )
}
print( tabSP)
plot( tabSP, log="xy", xlab="n", ylab="time (seconds)",
col="grey", pch=16)
y<- log10(tabSP[,2])
x<- log10(tabSP[,1])
lm( y~x)
sizes<- c(100, 200, 400,  500, 750, 1000, 2000, 3000)
NTotal<- length( sizes)
tabChol<- matrix( NA, nrow= NTotal, ncol=4)
dimnames(tabChol)<- list( NULL, c("N","Dense",
"Sparse","speedup"))
for(k in 1:NTotal) {
N<- sizes[k]
#weights are a 4th differece
# sparse matrix construction using LatticeKrig utility
SMat <- LKDiag( c(1,  -10,   27,  -10,    1), N)
# convert to full ( now the zeroes are consider real values)
FMat <- spam2full(SMat)
# dense matrix Cholesky
startTime <- Sys.time() #
FChol <- chol(FMat)
deltaF<- as.numeric(Sys.time() - startTime) #
# sparse matrix Cholesky
startTime <- Sys.time()
SChol <- chol(SMat)
deltaS<- as.numeric(Sys.time() - startTime )
tabChol[k,]<- c(N,deltaF, deltaS, deltaF/deltaS )
}
print( tabChol)
matplot( N, cbind(deltaF, deltaS ), type="p" pch=c( "F","S"),
matplot( N, cbind(deltaF, deltaS ), type="p", pch=c( "F","S"),
xlab="N", ylab="time (sec)")
deltaF
N
matplot( N, tabChol[,2:3], type="p", pch=c( "F","S"),
xlab="N", ylab="time (sec)")
matplot( tabChol[,1], tabChol[,2:3], type="p", pch=c( "F","S"),
xlab="N", ylab="time (sec)")
matplot( tabChol[,1], tabChol[,2:3], type="p", pch=c( "F","S"),
xlab="N", ylab="time (sec)", log="xy")
sizes<- c(100, 200, 400,  500, 750, 1000, 2000, 3000, 4000, 5000)
NTotal<- length( sizes)
tabChol<- matrix( NA, nrow= NTotal, ncol=4)
dimnames(tabChol)<- list( NULL, c("N","Dense",
"Sparse","speedup"))
for(k in 1:NTotal) {
N<- sizes[k]
#weights are a 4th differece
# sparse matrix construction using LatticeKrig utility
SMat <- LKDiag( c(1,  -10,   27,  -10,    1), N)
# convert to full ( now the zeroes are consider real values)
FMat <- spam2full(SMat)
# dense matrix Cholesky
startTime <- Sys.time() #
FChol <- chol(FMat)
deltaF<- as.numeric(Sys.time() - startTime) #
# sparse matrix Cholesky
startTime <- Sys.time()
SChol <- chol(SMat)
deltaS<- as.numeric(Sys.time() - startTime )
tabChol[k,]<- c(N,deltaF, deltaS, deltaF/deltaS )
}
print( tabChol)
sizes<- c(100, 200, 400,  500, 750, 1000, 2000, 3000, 4000, 5000, 8000)
NTotal<- length( sizes)
tabChol<- matrix( NA, nrow= NTotal, ncol=4)
dimnames(tabChol)<- list( NULL, c("N","Dense",
"Sparse","speedup"))
for(k in 1:NTotal) {
N<- sizes[k]
#weights are a 4th differece
# sparse matrix construction using LatticeKrig utility
SMat <- LKDiag( c(1,  -10,   27,  -10,    1), N)
# convert to full ( now the zeroes are consider real values)
FMat <- spam2full(SMat)
# dense matrix Cholesky
startTime <- Sys.time() #
FChol <- chol(FMat)
deltaF<- as.numeric(Sys.time() - startTime) #
# sparse matrix Cholesky
startTime <- Sys.time()
SChol <- chol(SMat)
deltaS<- as.numeric(Sys.time() - startTime )
tabChol[k,]<- c(N,deltaF, deltaS, deltaF/deltaS )
}
print( tabChol)
matplot( tabChol[,1], tabChol[,2:3], type="p", pch=c( "F","S"),
xlab="N", ylab="time (sec)", log="xy")
xlab="N", ylab="time (sec)", log="xy")
dev.off()
sizes<- c(100, 200, 400,  500, 750, 1000, 2000, 3000, 4000, 5000, 8000)
NTotal<- length( sizes)
tabChol<- matrix( NA, nrow= NTotal, ncol=4)
dimnames(tabChol)<- list( NULL, c("N","Dense",
"Sparse","speedup"))
for(k in 1:NTotal) {
N<- sizes[k]
#weights are a 4th differece
# sparse matrix construction using LatticeKrig utility
SMat <- LKDiag( c(1,  -10,   27,  -10,    1), N)
# convert to full ( now the zeroes are consider real values)
FMat <- spam2full(SMat)
# dense matrix Cholesky
startTime <- Sys.time() #
FChol <- chol(FMat)
deltaF<- as.numeric(Sys.time() - startTime) #
# sparse matrix Cholesky
startTime <- Sys.time()
SChol <- chol(SMat)
deltaS<- as.numeric(Sys.time() - startTime )
tabChol[k,]<- c(N,deltaF, deltaS, deltaF/deltaS )
}
print( tabChol)
matplot( tabChol[,1], tabChol[,2:3], type="p", pch=c( "F","S"),
xlab="N", ylab="time (sec)", log="xy")
y<- log10(tabChol[,2])
x<- log10(tabChol[,1])
lm( y~x)
y<- log10(tabChol[,3])
x<- log10(tabChol[,1])
lm( y~x)
setwd("~/Dropbox/Home/Teaching/ISI Short Course June 1-3 Materials/Day 2 Materials")
setwd("~/Dropbox/~/Dropbox/Home/Teaching/ISI Short Course June 1-3 Materials/Day 2 Materials")
setwd("~/Dropbox/Home/Teaching/ISI Short Course June 1-3 Materials/Day 2 Materials")
library( LatticeKrig)
fields.style()
u<- seq( 0,1,length.out=10)
sGrid<- seq( 0,1,length.out= 100)
Omega<- exp( -rdist( u,u)/.2)
X<- Wendland2.2( rdist( sGrid, u)/.4)
matplot( sGrid, X, type="l")
covG<- X%*%Omega%*%t(X)
locs<- c( 10, 20, 50, 85)
library( viridisLite)
pdf("pix/FRKCovCoef.pdf", width=6, height =6)
image.plot( u, u , Omega, col=viridis(16),
cex=3)
title("Covariance of coefficents",cex=10 )
dev.off()
pdf("pix/FRKCovImage.pdf", width=6, height =6)
fields.style()
image.plot( sGrid, sGrid, covG, col=viridis(256))
yline(sGrid[locs], col="grey", lwd=3)
title("Covariance of g", cex=3)
dev.off()
source("~/Dropbox/Home/Teaching/ISI Short Course June 1-3 Materials/Day 2 Materials/plotsCov.R")
source("~/Dropbox/Home/Teaching/ISI Short Course June 1-3 Materials/Day 2 Materials/plotsCov.R")
source("~/Dropbox/Home/Teaching/ISI Short Course June 1-3 Materials/Day 2 Materials/plotsCov.R")
y<- log10(tabChol[5:12,2])
knitr::opts_chunk$set(echo = TRUE, fig.width=5, fig.height=5, fig.align = "center")
suppressMessages(library( LatticeKrig))
set.seed(222)
tabSP<- NULL
nObs<- c(100, 200, 400,  500, 750, 1000, 2000, 3000)
for( n in nObs ){
x<- cbind( seq( 0,1,,n))
Sigma<- Matern( rdist(x,x)/.15, smoothness = 1.0)
U<- rnorm(n)
E<- rnorm(n)
# add in a linear part too to match fitting
y<-   (1 + x) + t(chol(Sigma))%*%U  + .05*E
# fix the range to compare with example later on
elapsedTime<- system.time(
out<- spatialProcess( x,y, aRange=.15 )
)
#print(c( n,elapsedTime[3]) )
tabSP<-  rbind( tabSP, c( n,elapsedTime[3]) )
}
source("~/Dropbox/Home/Teaching/ISI Short Course June 1-3 Materials/Day 2 Materials/plotsCov.R")
print( tabSP)
plot( tabSP, log="xy", xlab="n", ylab="time (seconds)",
col="grey", pch=16)
y<- log10(tabSP[,2])
x<- log10(tabSP[,1])
lm( y~x)
sizes<- c(100, 200, 400,  500, 750, 1000, 2000, 3000, 4000, 5000, 8000, 10000)
NTotal<- length( sizes)
tabChol<- matrix( NA, nrow= NTotal, ncol=4)
dimnames(tabChol)<- list( NULL, c("N","Dense",
"Sparse","speedup"))
for(k in 1:NTotal) {
N<- sizes[k]
#weights are a 4th differece
# sparse matrix construction using LatticeKrig utility
SMat <- LKDiag( c(1,  -10,   27,  -10,    1), N)
# convert to full ( now the zeroes are consider real values)
FMat <- spam2full(SMat)
# dense matrix Cholesky
startTime <- Sys.time() #
FChol <- chol(FMat)
deltaF<- as.numeric(Sys.time() - startTime) #
# sparse matrix Cholesky
startTime <- Sys.time()
SChol <- chol(SMat)
deltaS<- as.numeric(Sys.time() - startTime )
tabChol[k,]<- c(N,deltaF, deltaS, deltaF/deltaS )
}
print( tabChol)
matplot( tabChol[,1], tabChol[,2:3], type="p", pch=c( "D","S"),
xlab="N", ylab="time (sec)", log="xy")
title("Cholesky timing dense (D) vs sparse (S)
for matrix with 2 off-diagonal  bands ")
y<- log10(tabChol[5:12,2])
x<- log10(tabChol[5:12,1])
lm( y~x)
y<- log10(tabChol[5:12,3])
x<- log10(tabChol[5:12,1])
lm( y~x)
help( "LKSphere")
LKinfo<- LKrigSetup( s, startingLevel=4 ,nlevel=1,
a.wght=1.05,
LKGeometry="LKSphere" )
library(LatticeKrig)
data(CO2)
s<- CO2$lon.lat
z<- CO2$y
dim( s)
bubblePlot( s,z, highlight=FALSE, size=.4)
world( add=TRUE, col="magenta")
#  921 locations
ind1<-which(
s[,1]>= -110 & s[,1] <= -60 &
s[,2]>=   20 & s[,2] <=  55
)
# 1884 locations
ind2<- which(
s[,1]>= -120 & s[,1] <= -50 &
s[,2]>=  0 & s[,2] <=  55
)
# 3420 locations
ind3<- which(
s[,1]>= -120 & s[,1] <= -50 &
s[,2]>=  -55 & s[,2] <=  55
)
system.time(
fit1<- spatialProcess(s[ind1,], z[ind1], cov.function="Tps.cov")
)
# for 961 locations get about 2 seconds
system.time(
fit2<- spatialProcess(s[ind2,], z[ind2], cov.function="Tps.cov" )
)
# for n=1884 get about 7 seconds
system.time(
fit3<- spatialProcess(s[ind3,], z[ind3], cov.function="Tps.cov" )
)
# for n=3420 get about 35 seconds
# increasing n by 2 => ~factor of 5
#    O( n^3) complexity implies factor of 8
# approx thin plate spline fit using fixed rank Kriging
system.time(
fit4<- LatticeKrig(s, z, a.wght = 4.01 )
)
system.time(
fit4<- LatticeKrig(s, z, a.wght = 4.01, normalize=FALSE )
)
fit4
LKinfo<- LKrigSetup( s, startingLevel=4 , nlevel=1,
a.wght=1.05,
LKGeometry="LKSphere" )
LKinfo
LKinfo<- LKrigSetup( s, startingLevel=6 , nlevel=1,
a.wght=1.05,
LKGeometry="LKSphere" )
LKinfo
fit4
LKinfo<- LKrigSetup( s, startingLevel=4 , nlevel=3,
a.wght=1.05,
alpha=c( 1, .25,.25^2),
LKGeometry="LKSphere" )
LKinfo0
LKinfo
LKInfo<- LKrigSetup( s, startingLevel=4 , nlevel=3,
a.wght=1.05,
alpha=c( 1, .25,.25^2),
LKGeometry="LKSphere" )
system.time(
fit5<- LatticeKrig(s, z, LKinfo=LKinfo)
)
surface( fit5)
surface( fit4)
fit5
fit4
help( LKCylinder)
LKInfo<- LKrigSetup( s, startingLevel=4 , nlevel=3,
a.wght=1.05,
alpha=c( 1, .25,.25^2),
LKGeometry="LKRing" )
system.time(
fit5<- LatticeKrig(s, z, LKinfo=LKinfo)
)
system.time(
fit5<- LatticeKrig(s, z, a.wght=4.01,
LKGeometry="LKRing" )
)
fit4
fit4$alpha
fit4$LKinfo
names( fit4$LKinfo$alpha)
( fit4$LKinfo$alpha)
alpha<- fit4$LKinfo$alpha
system.time(
fit5<- LatticeKrig(s, z, a.wght=4.01, alpha=alpha, nlevel=3,
LKGeometry="LKRing" )
)
fit5
fit4
alpha<- fit4$LKinfo$alpha
LKInfo<- LKrigSetup( s, startingLevel=5 , nlevel=3,
a.wght=1.05,
alpha=alpha,
LKGeometry="LKSphere" )
LKInfo
alpha<- fit4$LKinfo$alpha
LKInfo<- LKrigSetup( s, startingLevel=4 , nlevel=3,
a.wght=1.05,
alpha=alpha,
LKGeometry="LKSphere" )
LKInfo
system.time(
fit5<- LatticeKrig(s, z, LKinfo=LKinfo)
)
26000/ 3600
.5*7.22^3
.5*7.22^3/60
system.time(
fit2<- spatialProcess(s[ind2,], z[ind2], cov.function="Tps.cov" )
)
# for n=1884 get about 7 seconds
# a conservative  lower bound  for the full data set is
# 3 hours ...
surface( fit2)
world( add=TRUE, col="magenta")
title("subset of CO2 data")
26000/1800
.5*14^3/60
.5*(14^3)/60
surface( fit2)
world( add=TRUE, col="magenta")
title("subset of CO2 data")
system.time(
fit4<- LatticeKrig(s, z, a.wght = 4.01 )
)
ind2<- which(
s[,1]>= -120 & s[,1] <= -60 &
s[,2]>=  -10 & s[,2] <=  55
)
system.time(
fit2<- spatialProcess(s[ind2,], z[ind2], cov.function="Tps.cov" )
)
surface( fit2)
world( add=TRUE, col="magenta")
title("subset of CO2 data")
source("~/Dropbox/Home/Teaching/ISI Short Course June 1-3 Materials/Day 2 Materials/LabsDay2/LatticeKrigLab3.R")
